import{bl as q,bm as z,bn as B,bo as A,bp as p,bq as K,br as V,bs as d,bt as F,bu as j,bv as I,aK as g,bw as N,ah as G,ai as R,bx as U,by as L,bz as J,bA as W,bB as X,bC as M,bD as H}from"./index-0_l9pkkQ.js";function $(r){throw new Error(`Should not reach this with value ${r}`)}const P=(r,t)=>r.map(s=>s[t]);class Q{constructor(t,s){this.root=new Y(t,s)}subset(t){const s=[];return this._subset(t,a=>s.push(...a[q])),s}debugTag(t){const s=[];return this._subset(t,a=>s.push(...a[z])),s}_subset(t,s){const a=t.length;function c(n,e){n<a?e.subset(t[n]).forEach(i=>c(n+1,i)):s(e.leaf)}c(0,this.root)}}let Y=class C{constructor(t,s){if(this.children=[],t>0)for(const[a,c]of Object.entries(s)){const n=new Map;for(const[e,i]of Object.entries(c))n.set(+e,new C(t-1,i));this.children.push({mask:+a,map:n})}else this.leaf=s}subset(t){return this.children.map(({mask:s,map:a})=>a.get(t&s)).filter(s=>!!s)}};class S{constructor(t){this.root=new _(void 0),this.keys=t,this.empty=this.at({})}at(t){const s=this.keys.get(t),a=s.reduce((c,n)=>c.child(n),this.root);return a.leaf||(a.leaf=new x(t,s,this.keys,a)),a.leaf}}class _{constructor(t){this.children=new Map,this.parent=t}child(t){let s=this.children.get(t);return s||(s=new _(this),this.children.set(t,s),s)}}class x{constructor(t,s,a,c){this.tag=t,this.id=s,this.keys=a,this.internal=c}with(t){const{id:s,firstReplacedByte:a}=this.keys.combine(this.id,t);let c=this.internal;for(let n=a;n<this.keys.tagLen;n++)c=c.parent;return c=s.slice(a).reduce((n,e)=>n.child(e),c),c.leaf||(c.leaf=new x({...this.tag,...t},s,this.keys,c)),c.leaf}}const w={sum:r=>r.reduce((t,s)=>t+s,0),prod:r=>r.reduce((t,s)=>t*s,1),min:r=>Math.min(...r),max:r=>Math.max(...r),sumfrac:([r,t])=>r/(r+t),unique:([r])=>r},k={match:([r,t])=>r===t?0:1,thres:([r,t])=>r>=t?0:1,lookup:([r],t)=>t[r]??0},b=r=>P(r,"val");let T=class{constructor(t,...s){this.keys=new B(t),this.nodes=new Q(t.tagLen,A(s)),this.cache=new S(this.keys)}gather(t){return this._gather(this.cache.at(t)).pre}compute(t){return this._compute(t,this.cache.empty)}_gather(t){if(t.val)return t.val;const s=this.nodes.subset(t.id).flatMap(a=>a.op==="reread"?this._gather(t.with(a.tag)).pre:[this.markGathered(t.tag,a,this._compute(a,t))]);return t.val={pre:s}}_compute(t,s){const a=(n,e,i,o)=>Object.freeze({val:n,meta:this.computeMeta(t,n,e,i,o)}),{op:c}=t;switch(c){case"const":return a(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const n=t.x.map(e=>this._compute(e,s));return a(w[c](b(n),t.ex),n,[])}case"thres":case"match":case"lookup":{const n=t.br.map(u=>this._compute(u,s)),e=k[c](b(n),t.ex),i=[...Array(t.x.length)],o=i[e]=this._compute(t.x[e],s);return a(o.val,i,n)}case"subscript":{const n=this._compute(t.br[0],s);return a(t.ex[n.val],[],[n])}case"vtag":return a(s.tag[t.ex]??"",[],[]);case"tag":{const n=s.with(t.tag),e=this._compute(t.x[0],n);return a(e.val,[e],[],n.tag)}case"dtag":{const n=t.br.map(o=>this._compute(o,s)),e=s.with(Object.fromEntries(n.map((o,u)=>[t.ex[u],o.val]))),i=this._compute(t.x[0],e);return a(i.val,[i],n,e.tag)}case"read":{const n=s.with(t.tag),e=this._gather(n),{pre:i}=e,o=t.ex??"unique";if(e[o])return e[o];const u=w[o](b(i),void 0);return e[o]=a(u,i,[],n.tag)}case"custom":{const n=t.x.map(e=>this._compute(e,s));return a(this.computeCustom(b(n),t.ex),n,[])}default:$(c)}}markGathered(t,s,a){return a}computeCustom(t,s){throw new Error(`Unsupported custom node ${s} in Calculator`)}computeMeta(t,s,a,c,n){}};function ct(r,t,s){function a(e,i){if(e.val)return e.val;const o=s(e.tag);return e.val=o?[K(o,i)]:t.nodes.subset(e.id).flatMap(u=>u.op!=="reread"?n(u,e):a(e.with(u.tag),i)),e.val}function c(e,i,o){return e.every(u=>u.op==="const")?p(w[i](e.map(u=>u.ex),o)):{op:i,x:e,br:[]}}function n(e,i){const{op:o}=e;switch(o){case"const":return e;case"read":{const u=a(i.with(e.tag),e.ex);return e.ex===void 0?u[0]??p(void 0):c(u,e.ex,e.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=e.x.map(l=>n(l,i));return c(u,o,e.ex)}case"thres":case"match":case"lookup":{const u=e.br.map(l=>n(l,i));if(u.every(l=>l.op==="const")){const l=k[e.op](u.map(m=>m.ex),e.ex);return n(e.x[l],i)}return{...e,x:e.x.map(l=>n(l,i)),br:u}}case"subscript":{const u=n(e.br[0],i);return u.op==="const"?p(e.ex[u.ex]):{...e,br:[u]}}case"vtag":return p(i.tag[e.ex]??"");case"tag":return n(e.x[0],i.with(e.tag));case"dtag":{const u=e.br.map(m=>n(m,i));if(u.some(m=>m.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const l=i.with(Object.fromEntries(u.map((m,h)=>[e.ex[h],m.ex])));return n(e.x[0],l)}case"custom":return{...e,x:e.x.map(u=>n(u,i))};default:$(o)}}return r.map(e=>n(e,new S(t.keys).empty))}function Z(r,t){const s=new Map;function a(c){const n=s.get(c);if(n)return n;const e=t(c,a);return s.set(c,e),e}return tt(r,a)}function tt(r,t){const s=r.map(t);return r.every((a,c)=>a===s[c])?r:s}const et={arithmetic:w,branching:k},v=Symbol();class st extends T{constructor(t,s){super(t.keys),this.gathering=new Set,this.nodes=t.nodes,this.tagStr=s,this.custom=t.computeCustom}_gather(t){if(this.gathering.has(t))throw new Error("Loop detected");this.gathering.add(t);const s=this.__gather(t);return this.gathering.delete(t),s}__gather(t){return super._gather(t)}_compute(t,s){try{return super._compute(t,s)}catch(a){return{val:NaN,meta:{note:`err: ${a.message} in ${this.tagStr(s.tag)}`,formula:this.nodeString(t),deps:[],[v]:!0}}}}computeMeta(t,s,a,c,n){function e(o){return typeof o!="number"?`"${o}"`:Math.round(o)===o?`${o}`:o.toFixed(2)}const i={note:"",formula:`[${e(s)}] ${this.nodeString(t)}`,deps:[...a.map(o=>o==null?void 0:o.meta).filter(o=>!!o),...c.map(o=>o.meta)].flatMap(o=>o[v]?[o]:o.deps),[v]:t.op==="read"};return t.op==="read"?(n=Object.fromEntries(Object.entries(n).filter(([o,u])=>u)),i.note=`gather ${a.length} node(s) for ${this.tagStr(n)}`,i.formula=`[${e(s)}] read ${this.nodeString(t)}`,i.deps=a.map(o=>o.meta)):delete i.note,i}computeCustom(t,s){return this.custom(t,s)}nodeString(t){return Z([t],(s,a)=>{const{op:c,tag:n,br:e,x:i}=s;let{ex:o}=s;if(c==="const")return`${o}`;if(c==="read")return this.tagStr(n,o);c==="subscript"&&(o=void 0);const u=[];return o&&u.push(JSON.stringify(o)),n&&u.push(this.tagStr(n)),u.push(...e.map(a),...i.map(a)),`${c}(`+u.join(", ")+")"})[0]}}const rt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class nt extends T{computeMeta({op:t,ex:s},a,c,n,e){const i={...rt},o=c.filter(h=>!!h).map(h=>O(h,i));n.forEach(h=>O(h,i));function u(h,f){return!f.tag&&h?{tag:h,...f}:f}function l(h,f){return u(e,{op:h,ops:f,...i})}function m(h){const f=h.meta,y=f.conds===i.conds;return u(e,y?f:{...f,...i})}if(t==="read"&&s!==void 0){if(s==="min"||s==="max")return m(o.find(h=>h.val===a));t=s,s=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let h=o;if(h.length>1){const f=at[t]([],s);h=h.filter(y=>y.val!==f)}return h.length===1?m(h[0]):h.length===0?l("const",[]):l(t,h)}case"const":case"vtag":case"subscript":return l("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return m(o[0]);case"read":return Object.freeze(m(o[0]));case"custom":return l(s,o);default:V(t)}}markGathered(t,s,a){let c=!1;const n=a.val,e={...Object.freeze(a.meta)};if(t.qt==="cond"){const{src:i,dst:o,sheet:u,q:l}=t;e.conds={[o??"all"]:{[i??"all"]:{[u]:{[l]:n}}}},c=!0}return Object.freeze(e),c?{val:n,meta:e}:a}listFormulas(t){return this.gather(t.tag).filter(s=>s.val).map(({val:s,meta:a})=>d.withTag(a.tag)[s])}listCondFormulas(t){return this.listFormulas(t).map(s=>this.compute(s).meta.conds).reduce(E,{})}toDebug(){return new st(this,F)}}function O(r,t){const{conds:s,...a}=r.meta;return t.conds=E(t.conds,s),Object.isFrozen(r.meta)?r:{val:r.val,meta:a}}function E(r,t){return D(r,t,(s,a)=>typeof a=="number"?a:void 0)}function D(r,t,s){const a=s(r,t);if(a!==void 0)return a;if(Object.keys(r).length<Object.keys(t).length&&([r,t]=[t,r]),!Object.keys(t).length)return r;let c=!1;const n={...r};for(const[e,i]of Object.entries(t)){const o=n[e],u=e in n?D(o,i,s):i;o!==u&&(n[e]=u,c=!0)}return c?n:r}function ut(r,...t){return t.map(({tag:s,value:a})=>({tag:{...s,src:r},value:a}))}function lt(r){const{lvl:t,basic:s,skill:a,ult:c,talent:n,ascension:e,eidolon:i}=j.char,{char:o,iso:u,[r.key]:l}=d.withAll("sheet",[]);return[o.reread(l),u.reread(l),t.add(r.level),s.add(r.basic),a.add(r.skill),c.add(r.ult),n.add(r.talent),e.add(r.ascension),i.add(r.eidolon),...I.map(m=>g.char[`statBoost${m}`].add(r.statBoosts[m]?1:0)),...N.map(m=>g.char[`bonusAbility${m}`].add(r.bonusAbilities[m]?1:0)),g.premod.crit_.add(.05),g.premod.crit_dmg_.add(.5)]}function ht(r){if(!r)return[];const{lvl:t,ascension:s,superimpose:a}=j.lightCone;return[d.sheet("lightCone").reread(d.sheet(r.key)),t.add(r.level),s.add(r.ascension),a.add(r.superimpose)]}function mt(r){const{common:{count:t},premod:s}=G(R,{sheet:"relic",et:"self"}),a={},c={};for(const{set:n,stats:e}of r){const i=a[n];i===void 0?a[n]=1:a[n]=i+1;for(const{key:o,value:u}of e){const l=c[o];l===void 0?c[o]=u:c[o]=l+u}}return[d.sheet("agg").reread(d.sheet("relic")),d.withTag({sheet:"relic",qt:"premod"}).reread(d.sheet("dyn")),...Object.entries(c).map(([n,e])=>U(s,n).sheet("dyn").add(e)),...Object.entries(a).map(([n,e])=>t.sheet(n).add(e))]}function dt(r){const t=d.with("et","team"),{self:s,enemy:a,teamBuff:c,notSelfBuff:n}=d.sheet("agg").withAll("et",[]);return[r.map(e=>d.withTag({et:"target",dst:e}).reread(d.withTag({et:"self",dst:null,src:e}))),r.flatMap(e=>{const i=s.with("src",e);return r.map(o=>i.reread(c.withTag({dst:e,src:o,name:null})))}),r.flatMap(e=>{const i=s.with("src",e);return r.filter(o=>o!==e).map(o=>i.reread(n.withTag({dst:e,src:o,name:null})))}),r.map(e=>a.reread(d.withTag({et:"enemyDeBuff",dst:null,src:e,name:null}))),r.flatMap((e,i)=>{const{stackIn:o,stackTmp:u}=d.withAll("qt",[]),l=d.withTag({src:e,et:"self"});return[l.with("qt","stackTmp").add(L(o,0,i+1)),l.with("qt","stackOut").add(J(u.max.with("et","team"),i+1,o))]}),r.map(e=>t.add(d.withTag({src:e,et:"self"}).sum))].flat()}function ft(r,t){return t?Object.entries(t).flatMap(([s,a])=>Object.entries(a).flatMap(([c,n])=>{const e=W(c,s,r);return Object.entries(n).map(([i,o])=>e(i,o))})):[]}function pt(r){const t=X(M,r);return new nt(M,H,t)}export{ft as a,lt as c,ct as d,ht as l,mt as r,pt as s,dt as t,ut as w};
