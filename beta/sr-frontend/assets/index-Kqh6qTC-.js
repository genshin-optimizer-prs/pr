import{bl as q,bm as z,bn as g,bo as A,bp as B,bq as p,br as V,bs as E,bt as I,aK as w,bu as K,ah as F,ai as N,bv as G,bw as R,bx as U,by as J,bz as W,bA as O,bB as X}from"./index-B85t5zpA.js";function C(o){throw new Error(`Should not reach this with value ${o}`)}const H=(o,t)=>o.map(e=>e[t]);class P{constructor(t,e){this.internal=new Q(e),this.tagLen=t}allValues(){const t=[],e=this.tagLen;function r(i,n){n===e?t.push(...i.values):i.children.forEach(c=>c.forEach(a=>r(a,n+1)))}return r(this.internal,0),t}subset(t){const e=[],r=this.tagLen;function i(n,c){c===r?e.push(...n.values):n.subset(t[c]).forEach(a=>i(a,c+1))}return i(this.internal,0),e}cache(t){const e=t.tagLen;let r=new M(void 0,[this.internal]);for(let i=0;i<e;i++)r=r.child(0);return new k(new Int32Array(e).fill(0),{},t,r)}}let Q=class ${constructor(t){const{"":e,...r}=t;this.children=new Map,this.values=e??[];for(const[i,n]of Object.entries(r)){const c=new Map;this.children.set(+i,c);for(const[a,s]of Object.entries(n))c.set(+a,new $(s))}}subset(t){return[...this.children].map(([e,r])=>r.get(t&e)).filter(e=>e)}};class k{constructor(t,e,r,i){this.id=t,this.tag=e,this.keys=r,this.tagLen=r.tagLen,this.internal=i}subset(){return this.internal.entries.flatMap(t=>t.values)}tags(){throw new Error("Tags are not tracked in production")}with(t){const{tagLen:e}=this.keys,{id:r,firstReplacedByte:i}=this.keys.combine(this.id,t);let n=this.internal;for(let c=i;c<e;c++)n=n.parent;for(let c=i;c<e;c++)n=n.child(r[c]);return new k(r,{...this.tag,...t},this.keys,n)}}class M{constructor(t,e){this.children=new Map,this.entries=e,this.parent=t}child(t){const e=this.children.get(t);if(e)return e;const r=this.entries.flatMap(n=>n.subset(t)),i=new M(this,r);return this.children.set(t,i),i}}class T{constructor(t,e){this.internal=new v(e),this.tagLen=t}refExact(t){let e=this.internal;const r=this.tagLen;for(let i=0;i<r;i++)e=e.exact(t[i]);return e.values}}class v{constructor(t){const{"":e,...r}=t;this.children=new Map,this.values=e??[];for(const i of Object.values(r))for(const[n,c]of Object.entries(i))this.children.set(+n,new v(c))}exact(t){let e=this.children.get(t);return e||(e=new v({}),this.children.set(t,e),e)}}const y={sum:o=>o.reduce((t,e)=>t+e,0),prod:o=>o.reduce((t,e)=>t*e,1),min:o=>Math.min(...o),max:o=>Math.max(...o),sumfrac:([o,t])=>o/(o+t),unique:([o])=>o},_={match:([o,t])=>o===t?0:1,thres:([o,t])=>o>=t?0:1,lookup:([o],t)=>t[o]??0},b=o=>H(o,"val");let S=class{constructor(t,...e){this.keys=new q(t),this.nodes=new P(t.tagLen,z(e)),this.calculated=new T(t.tagLen,{})}gather(t){return this._gather(this.nodes.cache(this.keys).with(t)).pre}compute(t){return this._compute(t,this.nodes.cache(this.keys))}_gather(t){const e=this.calculated.refExact(t.id);return e.length||e.push({pre:t.subset().flatMap(r=>r.op==="reread"?this._gather(t.with(r.tag)).pre:[this.markGathered(t.tag,r,this._compute(r,t))])}),e[0]}_compute(t,e){const r=(n,c,a,s)=>Object.freeze({val:n,meta:this.computeMeta(t,n,c,a,s)}),{op:i}=t;switch(i){case"const":return r(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const n=t.x.map(c=>this._compute(c,e));return r(y[i](b(n),t.ex),n,[])}case"thres":case"match":case"lookup":{const n=t.br.map(h=>this._compute(h,e)),c=_[i](b(n),t.ex),a=[...Array(t.x.length)],s=this._compute(t.x[c],e);return a[c]=s,r(s.val,a,n)}case"subscript":{const n=this._compute(t.br[0],e);return r(t.ex[n.val],[],[n])}case"vtag":return r(e.tag[t.ex]??"",[],[]);case"tag":{const n=e.with(t.tag),c=this._compute(t.x[0],n);return r(c.val,[c],[],n.tag)}case"dtag":{const n=t.br.map(s=>this._compute(s,e)),c=e.with(Object.fromEntries(n.map((s,h)=>[t.ex[h],s.val]))),a=this._compute(t.x[0],c);return r(a.val,[a],n,c.tag)}case"read":{const n=e.with(t.tag),c=this._gather(n),{pre:a}=c,s=t.ex??"unique";if(c[s])return c[s];const h=y[s](b(a),void 0);return c[s]=r(h,a,[],n.tag),c[s]}case"custom":{const n=t.x.map(c=>this._compute(c,e));return r(this.computeCustom(b(n),t.ex),n,[])}default:C(i)}}markGathered(t,e,r){return r}computeCustom(t,e){throw new Error(`Unsupported custom node ${e} in Calculator`)}computeMeta(t,e,r,i,n){}};function ut(o,t,e){function r(a,s){const h=e(a.tag);return h?[A(h,s)]:a.subset().flatMap(u=>u.op!=="reread"?n(u,a):r(a.with(u.tag),s))}function i(a,s,h){return a.every(u=>u.op==="const")?g(y[s](a.map(u=>u.ex),h)):{op:s,x:a,br:[]}}function n(a,s){const{op:h}=a;switch(h){case"const":return a;case"read":{const u=r(s.with(a.tag),a.ex);return a.ex===void 0?u[0]??g(void 0):i(u,a.ex,a.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=a.x.map(d=>n(d,s));return i(u,h,a.ex)}case"thres":case"match":case"lookup":{const u=a.br.map(d=>n(d,s));if(u.every(d=>d.op==="const")){const d=_[a.op](u.map(l=>l.ex),a.ex);return n(a.x[d],s)}return{...a,x:a.x.map(d=>n(d,s)),br:u}}case"subscript":{const u=n(a.br[0],s);return u.op==="const"?g(a.ex[u.ex]):{...a,br:[u]}}case"vtag":return g(s.tag[a.ex]??"");case"tag":return n(a.x[0],s.with(a.tag));case"dtag":{const u=a.br.map(l=>n(l,s));if(u.some(l=>l.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const d=s.with(Object.fromEntries(u.map((l,f)=>[a.ex[f],l.ex])));return n(a.x[0],d)}case"custom":return{...a,x:a.x.map(u=>n(u,s))};default:C(h)}}const c=t.nodes.cache(t.keys);return o.map(a=>n(a,c))}function Y(o,t){const e=new Map;function r(i){const n=e.get(i);if(n)return n;const c=t(i,r);return e.set(i,c),c}return tt(o,r)}function Z(o,t){const e=new Set;function r(i){e.has(i)||(t(i,r),e.add(i))}o.forEach(r)}function tt(o,t){const e=o.map(t);return o.every((r,i)=>r===e[i])?o:e}const et={arithmetic:y,branching:_},x=Symbol();class st extends S{constructor(t,e){super(t.keys),this.nodes=t.nodes,this.tagStr=e,this.custom=t.computeCustom}checkCycle(t){rt(t,this)}_gather(t){return super._gather(t)}_compute(t,e){try{return super._compute(t,e)}catch(r){return{val:NaN,meta:{note:`err: ${r.message} in ${this.tagStr(e.tag)}`,formula:this.nodeString(t),deps:[],[x]:!0}}}}computeMeta(t,e,r,i,n){function c(s){return typeof s!="number"?`"${s}"`:Math.round(s)===s?`${s}`:s.toFixed(2)}const a={note:"",formula:`[${c(e)}] ${this.nodeString(t)}`,deps:[...r.map(s=>s==null?void 0:s.meta).filter(s=>!!s),...i.map(s=>s.meta)].flatMap(s=>s[x]?[s]:s.deps),[x]:t.op==="read"};return t.op==="read"?(n=Object.fromEntries(Object.entries(n).filter(([s,h])=>h)),a.note=`gather ${r.length} node(s) for ${this.tagStr(n)}`,a.formula=`[${c(e)}] read ${this.nodeString(t)}`,a.deps=r.map(s=>s.meta)):delete a.note,a}computeCustom(t,e){return this.custom(t,e)}nodeString(t){return Y([t],(e,r)=>{const{op:i,tag:n,br:c,x:a}=e;let{ex:s}=e;if(i==="const")return`${s}`;if(i==="read")return this.tagStr(n,s);i==="subscript"&&(s=void 0);const h=[];return s&&h.push(JSON.stringify(s)),n&&h.push(this.tagStr(n)),h.push(...c.map(r),...a.map(r)),`${i}(`+h.join(", ")+")"})[0]}}function rt(o,t){const e=[],r=t.keys,i=new T(r.tagLen,{});function n(c){const a=c.tag,s=i.refExact(r.get(a));if(s[0]>0)throw console.log(e.slice(s[0]-1)),new Error("Cyclical dependencies found");if(s[0]==0)return;s[0]=e.push(a);const h=c.subset(),u=h.filter(l=>l.op!=="reread"),d=h.filter(l=>l.op==="reread");Z(u,(l,f)=>{switch(l.op){case"read":{const m=c.with(l.tag);n(m);return}case"tag":{f(l.x[0]);return}case"dtag":console.warn("Ignored dtag node while checking for cycles")}l.x.forEach(f),l.br.forEach(f)});for(const{tag:l}of d){const f=c.with(l);n(f)}s[0]=0,e.pop()}n(t.nodes.cache(t.keys).with(o))}const nt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class ot extends S{computeMeta({op:t,ex:e},r,i,n,c){const a={...nt},s=i.filter(l=>!!l).map(l=>j(l,a));n.forEach(l=>j(l,a));function h(l,f){return!f.tag&&l?{tag:l,...f}:f}function u(l,f){return h(c,{op:l,ops:f,...a})}function d(l){const f=l.meta,m=f.conds===a.conds;return h(c,m?f:{...f,...a})}if(t==="read"&&e!==void 0){if(e==="min"||e==="max")return d(s.find(l=>l.val===r));t=e,e=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let l=s;if(l.length>1){const f=at[t]([],e);l=l.filter(m=>m.val!==f)}return l.length===1?d(l[0]):l.length===0?u("const",[]):u(t,l)}case"const":case"vtag":case"subscript":return u("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return d(s[0]);case"read":return Object.freeze(d(s[0]));case"custom":return u(e,s);default:B(t)}}markGathered(t,e,r){let i=!1;const n=r.val,c={...Object.freeze(r.meta)};if(t.qt==="cond"){const{src:a,dst:s,sheet:h,q:u}=t;c.conds={[s??null]:{[a??null]:{[h]:{[u]:n}}}},i=!0}return Object.freeze(c),i?{val:n,meta:c}:r}listFormulas(t){return this.gather(t.tag).filter(e=>e.val).map(({val:e,meta:r})=>p.withTag(r.tag)[e])}listCondFormulas(t){return this.listFormulas(t).map(e=>this.compute(e).meta.conds).reduce(L,{})}toDebug(){return new st(this,V)}}function j(o,t){const{conds:e,...r}=o.meta;return t.conds=L(t.conds,e),Object.isFrozen(o.meta)?o:{val:o.val,meta:r}}function L(o,t){return D(o,t,(e,r)=>typeof r=="number"?r:void 0)}function D(o,t,e){const r=e(o,t);if(r!==void 0)return r;if(Object.keys(o).length<Object.keys(t).length&&([o,t]=[t,o]),!Object.keys(t).length)return o;let i=!1;const n={...o};for(const[c,a]of Object.entries(t)){const s=n[c],h=c in n?D(s,a,e):a;s!==h&&(n[c]=h,i=!0)}return i?n:o}function lt(o,...t){return t.map(({tag:e,value:r})=>({tag:{...e,src:o},value:r}))}function ht(o){const{lvl:t,basic:e,skill:r,ult:i,talent:n,ascension:c,eidolon:a}=E.char,{char:s,iso:h,[o.key]:u}=p.withAll("sheet",[]);return[s.reread(u),h.reread(u),t.add(o.level),e.add(o.basic),r.add(o.skill),i.add(o.ult),n.add(o.talent),c.add(o.ascension),a.add(o.eidolon),...I.map(d=>w.char[`statBoost${d}`].add(o.statBoosts[d]?1:0)),...K.map(d=>w.char[`bonusAbility${d}`].add(o.bonusAbilities[d]?1:0)),w.premod.crit_.add(.05),w.premod.crit_dmg_.add(.5)]}function dt(o){if(!o)return[];const{lvl:t,ascension:e,superimpose:r}=E.lightCone;return[p.sheet("lightCone").reread(p.sheet(o.key)),t.add(o.level),e.add(o.ascension),r.add(o.superimpose)]}function ft(o){const{common:{count:t},premod:e}=F(N,{sheet:"relic",et:"self"}),r={},i={};for(const{set:n,stats:c}of o){const a=r[n];a===void 0?r[n]=1:r[n]=a+1;for(const{key:s,value:h}of c){const u=i[s];u===void 0?i[s]=h:i[s]=u+h}}return[p.sheet("agg").reread(p.sheet("relic")),p.withTag({sheet:"relic",qt:"premod"}).reread(p.sheet("dyn")),...Object.entries(i).map(([n,c])=>G(e,n).sheet("dyn").add(c)),...Object.entries(r).map(([n,c])=>t.sheet(n).add(c))]}function pt(o){const t=p.with("et","team"),{self:e,enemy:r,teamBuff:i,notSelfBuff:n}=p.sheet("agg").withAll("et",[]);return[o.map(c=>p.withTag({et:"target",dst:c}).reread(p.withTag({et:"self",dst:null,src:c}))),o.flatMap(c=>{const a=e.with("src",c);return o.map(s=>a.reread(i.withTag({dst:c,src:s})))}),o.flatMap(c=>{const a=e.with("src",c);return o.map(s=>a.reread(n.withTag({dst:c,src:s}))).filter(({value:s})=>s.tag.dst!=s.tag.src)}),o.map(c=>r.reread(p.withTag({et:"enemyDeBuff",src:c,dst:"all"}))),o.slice(0,4).flatMap((c,a)=>{const{stackIn:s,stackTmp:h}=p.withAll("qt",[]),u=`${a}`,d=p.withTag({src:u,et:"self"});return[d.with("qt","stackTmp").add(R(s,0,a+1)),d.with("qt","stackOut").add(U(h.max.with("et","team"),a+1,s))]}),o.map(c=>t.add(p.withTag({src:c,et:"self"}).sum))].flat()}function mt(o,t){return Object.entries(t).flatMap(([e,r])=>Object.entries(r).flatMap(([i,n])=>{const c=J(i,e,o);return Object.entries(n).map(([a,s])=>c(a,s))}))}function gt(o){const t=W(O,o);return new ot(O,X,t)}export{mt as a,ht as c,ut as d,dt as l,ft as r,gt as s,pt as t,lt as w};
