import{bl as q,bm as z,bn as g,bo as A,bp as B,bq as p,br as V,bs as j,bt as I,aK as w,bu as K,ah as F,ai as N,bv as G,bw as R,bx as U,by as J,bz as W,bA as E,bB as X}from"./index-uiK8dO2X.js";function C(a){throw new Error(`Should not reach this with value ${a}`)}const H=(a,t)=>a.map(e=>e[t]);class P{constructor(t,e){this.internal=new Q(e),this.tagLen=t}allValues(){const t=[],e=this.tagLen;function s(i,n){n===e?t.push(...i.values):i.children.forEach(c=>c.forEach(o=>s(o,n+1)))}return s(this.internal,0),t}subset(t){const e=[],s=this.tagLen;function i(n,c){c===s?e.push(...n.values):n.subset(t[c]).forEach(o=>i(o,c+1))}return i(this.internal,0),e}cache(t){const e=t.tagLen;let s=new _(void 0,[this.internal]);for(let i=0;i<e;i++)s=s.child(0);return new k(new Int32Array(e).fill(0),{},t,s)}}let Q=class ${constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const[i,n]of Object.entries(s)){const c=new Map;this.children.set(+i,c);for(const[o,r]of Object.entries(n))c.set(+o,new $(r))}}subset(t){return[...this.children].map(([e,s])=>s.get(t&e)).filter(e=>e)}};class k{constructor(t,e,s,i){this.id=t,this.tag=e,this.keys=s,this.tagLen=s.tagLen,this.internal=i}subset(){return this.internal.entries.flatMap(t=>t.values)}tags(){throw new Error("Tags are not tracked in production")}with(t){const{tagLen:e}=this.keys,{id:s,firstReplacedByte:i}=this.keys.combine(this.id,t);let n=this.internal;for(let c=i;c<e;c++)n=n.parent;for(let c=i;c<e;c++)n=n.child(s[c]);return new k(s,{...this.tag,...t},this.keys,n)}}class _{constructor(t,e){this.children=new Map,this.entries=e,this.parent=t}child(t){const e=this.children.get(t);if(e)return e;const s=this.entries.flatMap(n=>n.subset(t)),i=new _(this,s);return this.children.set(t,i),i}}class T{constructor(t,e){this.internal=new v(e),this.tagLen=t}refExact(t){let e=this.internal;const s=this.tagLen;for(let i=0;i<s;i++)e=e.exact(t[i]);return e.values}}class v{constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const i of Object.values(s))for(const[n,c]of Object.entries(i))this.children.set(+n,new v(c))}exact(t){let e=this.children.get(t);return e||(e=new v({}),this.children.set(t,e),e)}}const y={sum:a=>a.reduce((t,e)=>t+e,0),prod:a=>a.reduce((t,e)=>t*e,1),min:a=>Math.min(...a),max:a=>Math.max(...a),sumfrac:([a,t])=>a/(a+t),unique:([a])=>a},M={match:([a,t])=>a===t?0:1,thres:([a,t])=>a>=t?0:1,lookup:([a],t)=>t[a]??0},b=a=>H(a,"val");let S=class{constructor(t,...e){this.keys=new q(t),this.nodes=new P(t.tagLen,z(e)),this.calculated=new T(t.tagLen,{})}gather(t){return this._gather(this.nodes.cache(this.keys).with(t)).pre}compute(t){return this._compute(t,this.nodes.cache(this.keys))}_gather(t){const e=this.calculated.refExact(t.id);return e.length||e.push({pre:t.subset().flatMap(s=>s.op==="reread"?this._gather(t.with(s.tag)).pre:[this.markGathered(t.tag,s,this._compute(s,t))])}),e[0]}_compute(t,e){const s=(n,c,o,r)=>Object.freeze({val:n,meta:this.computeMeta(t,n,c,o,r)}),{op:i}=t;switch(i){case"const":return s(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const n=t.x.map(c=>this._compute(c,e));return s(y[i](b(n),t.ex),n,[])}case"thres":case"match":case"lookup":{const n=t.br.map(h=>this._compute(h,e)),c=M[i](b(n),t.ex),o=[...Array(t.x.length)],r=this._compute(t.x[c],e);return o[c]=r,s(r.val,o,n)}case"subscript":{const n=this._compute(t.br[0],e);return s(t.ex[n.val],[],[n])}case"vtag":return s(e.tag[t.ex]??"",[],[]);case"tag":{const n=e.with(t.tag),c=this._compute(t.x[0],n);return s(c.val,[c],[],n.tag)}case"dtag":{const n=t.br.map(r=>this._compute(r,e)),c=e.with(Object.fromEntries(n.map((r,h)=>[t.ex[h],r.val]))),o=this._compute(t.x[0],c);return s(o.val,[o],n,c.tag)}case"read":{const n=e.with(t.tag),c=this._gather(n),{pre:o}=c,r=t.ex??"unique";if(c[r])return c[r];const h=y[r](b(o),void 0);return c[r]=s(h,o,[],n.tag),c[r]}case"custom":{const n=t.x.map(c=>this._compute(c,e));return s(this.computeCustom(b(n),t.ex),n,[])}default:C(i)}}markGathered(t,e,s){return s}computeCustom(t,e){throw new Error(`Unsupported custom node ${e} in Calculator`)}computeMeta(t,e,s,i,n){}};function ut(a,t,e){function s(o,r){const h=e(o.tag);return h?[A(h,r)]:o.subset().flatMap(u=>u.op!=="reread"?n(u,o):s(o.with(u.tag),r))}function i(o,r,h){return o.every(u=>u.op==="const")?g(y[r](o.map(u=>u.ex),h)):{op:r,x:o,br:[]}}function n(o,r){const{op:h}=o;switch(h){case"const":return o;case"read":{const u=s(r.with(o.tag),o.ex);return o.ex===void 0?u[0]??g(void 0):i(u,o.ex,o.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=o.x.map(d=>n(d,r));return i(u,h,o.ex)}case"thres":case"match":case"lookup":{const u=o.br.map(d=>n(d,r));if(u.every(d=>d.op==="const")){const d=M[o.op](u.map(l=>l.ex),o.ex);return n(o.x[d],r)}return{...o,x:o.x.map(d=>n(d,r)),br:u}}case"subscript":{const u=n(o.br[0],r);return u.op==="const"?g(o.ex[u.ex]):{...o,br:[u]}}case"vtag":return g(r.tag[o.ex]??"");case"tag":return n(o.x[0],r.with(o.tag));case"dtag":{const u=o.br.map(l=>n(l,r));if(u.some(l=>l.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const d=r.with(Object.fromEntries(u.map((l,f)=>[o.ex[f],l.ex])));return n(o.x[0],d)}case"custom":return{...o,x:o.x.map(u=>n(u,r))};default:C(h)}}const c=t.nodes.cache(t.keys);return a.map(o=>n(o,c))}function Y(a,t){const e=new Map;function s(i){const n=e.get(i);if(n)return n;const c=t(i,s);return e.set(i,c),c}return tt(a,s)}function Z(a,t){const e=new Set;function s(i){e.has(i)||(t(i,s),e.add(i))}a.forEach(s)}function tt(a,t){const e=a.map(t);return a.every((s,i)=>s===e[i])?a:e}const et={arithmetic:y,branching:M},x=Symbol();class st extends S{constructor(t,e){super(t.keys),this.nodes=t.nodes,this.tagStr=e,this.custom=t.computeCustom}checkCycle(t){rt(t,this)}_gather(t){return super._gather(t)}_compute(t,e){try{return super._compute(t,e)}catch(s){return{val:NaN,meta:{note:`err: ${s.message} in ${this.tagStr(e.tag)}`,formula:this.nodeString(t),deps:[],[x]:!0}}}}computeMeta(t,e,s,i,n){function c(r){return typeof r!="number"?`"${r}"`:Math.round(r)===r?`${r}`:r.toFixed(2)}const o={note:"",formula:`[${c(e)}] ${this.nodeString(t)}`,deps:[...s.map(r=>r==null?void 0:r.meta).filter(r=>!!r),...i.map(r=>r.meta)].flatMap(r=>r[x]?[r]:r.deps),[x]:t.op==="read"};return t.op==="read"?(n=Object.fromEntries(Object.entries(n).filter(([r,h])=>h)),o.note=`gather ${s.length} node(s) for ${this.tagStr(n)}`,o.formula=`[${c(e)}] read ${this.nodeString(t)}`,o.deps=s.map(r=>r.meta)):delete o.note,o}computeCustom(t,e){return this.custom(t,e)}nodeString(t){return Y([t],(e,s)=>{const{op:i,tag:n,br:c,x:o}=e;let{ex:r}=e;if(i==="const")return`${r}`;if(i==="read")return this.tagStr(n,r);i==="subscript"&&(r=void 0);const h=[];return r&&h.push(JSON.stringify(r)),n&&h.push(this.tagStr(n)),h.push(...c.map(s),...o.map(s)),`${i}(`+h.join(", ")+")"})[0]}}function rt(a,t){const e=[],s=t.keys,i=new T(s.tagLen,{});function n(c){const o=c.tag,r=i.refExact(s.get(o));if(r[0]>0)throw console.log(e.slice(r[0]-1)),new Error("Cyclical dependencies found");if(r[0]==0)return;r[0]=e.push(o);const h=c.subset(),u=h.filter(l=>l.op!=="reread"),d=h.filter(l=>l.op==="reread");Z(u,(l,f)=>{switch(l.op){case"read":{const m=c.with(l.tag);n(m);return}case"tag":{f(l.x[0]);return}case"dtag":console.warn("Ignored dtag node while checking for cycles")}l.x.forEach(f),l.br.forEach(f)});for(const{tag:l}of d){const f=c.with(l);n(f)}r[0]=0,e.pop()}n(t.nodes.cache(t.keys).with(a))}const nt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class ot extends S{computeMeta({op:t,ex:e},s,i,n,c){const o={...nt},r=i.filter(l=>!!l).map(l=>O(l,o));n.forEach(l=>O(l,o));function h(l,f){return!f.tag&&l?{tag:l,...f}:f}function u(l,f){return h(c,{op:l,ops:f,...o})}function d(l){const f=l.meta,m=f.conds===o.conds;return h(c,m?f:{...f,...o})}if(t==="read"&&e!==void 0){if(e==="min"||e==="max")return d(r.find(l=>l.val===s));t=e,e=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let l=r;if(l.length>1){const f=at[t]([],e);l=l.filter(m=>m.val!==f)}return l.length===1?d(l[0]):l.length===0?u("const",[]):u(t,l)}case"const":case"vtag":case"subscript":return u("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return d(r[0]);case"read":return Object.freeze(d(r[0]));case"custom":return u(e,r);default:B(t)}}markGathered(t,e,s){let i=!1;const n=s.val,c={...Object.freeze(s.meta)};if(t.qt==="cond"){const{src:o,dst:r,sheet:h,q:u}=t;c.conds={[r??null]:{[o??null]:{[h]:{[u]:n}}}},i=!0}return Object.freeze(c),i?{val:n,meta:c}:s}listFormulas(t){return this.gather(t.tag).filter(e=>e.val).map(({val:e,meta:s})=>p.withTag(s.tag)[e])}listCondFormulas(t){return this.listFormulas(t).map(e=>this.compute(e).meta.conds).reduce(L,{})}toDebug(){return new st(this,V)}}function O(a,t){const{conds:e,...s}=a.meta;return t.conds=L(t.conds,e),Object.isFrozen(a.meta)?a:{val:a.val,meta:s}}function L(a,t){return D(a,t,(e,s)=>typeof s=="number"?s:void 0)}function D(a,t,e){const s=e(a,t);if(s!==void 0)return s;if(Object.keys(a).length<Object.keys(t).length&&([a,t]=[t,a]),!Object.keys(t).length)return a;let i=!1;const n={...a};for(const[c,o]of Object.entries(t)){const r=n[c],h=c in n?D(r,o,e):o;r!==h&&(n[c]=h,i=!0)}return i?n:a}function lt(a,...t){return t.map(({tag:e,value:s})=>({tag:{...e,src:a},value:s}))}function ht(a){const{lvl:t,basic:e,skill:s,ult:i,talent:n,ascension:c,eidolon:o}=j.char,{char:r,iso:h,[a.key]:u}=p.withAll("sheet",[]);return[r.reread(u),h.reread(u),t.add(a.level),e.add(a.basic),s.add(a.skill),i.add(a.ult),n.add(a.talent),c.add(a.ascension),o.add(a.eidolon),...I.map(d=>w.char[`statBoost${d}`].add(a.statBoosts[d]?1:0)),...K.map(d=>w.char[`bonusAbility${d}`].add(a.bonusAbilities[d]?1:0)),w.premod.crit_.add(.05),w.premod.crit_dmg_.add(.5)]}function dt(a){if(!a)return[];const{lvl:t,ascension:e,superimpose:s}=j.lightCone;return[p.sheet("lightCone").reread(p.sheet(a.key)),t.add(a.level),e.add(a.ascension),s.add(a.superimpose)]}function ft(a){const{common:{count:t},premod:e}=F(N,{sheet:"relic",et:"self"}),s={},i={};for(const{set:n,stats:c}of a){const o=s[n];o===void 0?s[n]=1:s[n]=o+1;for(const{key:r,value:h}of c){const u=i[r];u===void 0?i[r]=h:i[r]=u+h}}return[p.sheet("agg").reread(p.sheet("relic")),p.withTag({sheet:"relic",qt:"premod"}).reread(p.sheet("dyn")),...Object.entries(i).map(([n,c])=>G(e,n).sheet("dyn").add(c)),...Object.entries(s).map(([n,c])=>t.sheet(n).add(c))]}function pt(a){const t=p.with("et","team"),{self:e,enemy:s,teamBuff:i,notSelfBuff:n}=p.sheet("agg").withAll("et",[]);return[a.map(c=>p.withTag({et:"target",dst:c}).reread(p.withTag({et:"self",dst:null,src:c}))),a.flatMap(c=>{const o=e.with("src",c);return a.map(r=>o.reread(i.withTag({dst:c,src:r})))}),a.flatMap(c=>{const o=e.with("src",c);return a.map(r=>o.reread(n.withTag({dst:c,src:r}))).filter(({value:r})=>r.tag.dst!=r.tag.src)}),a.map(c=>s.reread(p.withTag({et:"enemyDeBuff",src:c,dst:"all"}))),a.slice(0,4).flatMap((c,o)=>{const{stackIn:r,stackTmp:h}=p.withAll("qt",[]),u=`${o}`,d=p.withTag({src:u,et:"self"});return[d.with("qt","stackTmp").add(R(r,0,o+1)),d.with("qt","stackOut").add(U(h.max.with("et","team"),o+1,r))]}),a.map(c=>t.add(p.withTag({src:c,et:"self"}).sum))].flat()}function mt(a,t){return t?Object.entries(t).flatMap(([e,s])=>{const i=J(e,"all",a);return Object.entries(s).map(([n,c])=>i(n,c))}):[]}function gt(a){const t=W(E,a);return new ot(E,X,t)}export{mt as a,ht as c,ut as d,dt as l,ft as r,gt as s,pt as t,lt as w};
