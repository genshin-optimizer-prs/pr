import{bl as q,bm as z,bn as g,bo as A,bp as B,bq as p,br as V,bs as E,bt as I,aK as w,bu as K,ah as F,ai as N,bv as G,bw as R,bx as U,by as J,bz as W,bA as O,bB as X}from"./index-CsegcCww.js";function C(a){throw new Error(`Should not reach this with value ${a}`)}const H=(a,t)=>a.map(e=>e[t]);class P{constructor(t,e){this.internal=new Q(e),this.tagLen=t}allValues(){const t=[],e=this.tagLen;function s(i,n){n===e?t.push(...i.values):i.children.forEach(o=>o.forEach(c=>s(c,n+1)))}return s(this.internal,0),t}subset(t){const e=[],s=this.tagLen;function i(n,o){o===s?e.push(...n.values):n.subset(t[o]).forEach(c=>i(c,o+1))}return i(this.internal,0),e}cache(t){const e=t.tagLen;let s=new M(void 0,[this.internal]);for(let i=0;i<e;i++)s=s.child(0);return new k(new Int32Array(e).fill(0),{},t,s)}}let Q=class T{constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const[i,n]of Object.entries(s)){const o=new Map;this.children.set(+i,o);for(const[c,r]of Object.entries(n))o.set(+c,new T(r))}}subset(t){return[...this.children].map(([e,s])=>s.get(t&e)).filter(e=>e)}};class k{constructor(t,e,s,i){this.id=t,this.tag=e,this.keys=s,this.tagLen=s.tagLen,this.internal=i}subset(){return this.internal.entries.flatMap(t=>t.values)}tags(){throw new Error("Tags are not tracked in production")}with(t){const{tagLen:e}=this.keys,{id:s,firstReplacedByte:i}=this.keys.combine(this.id,t);let n=this.internal;for(let o=i;o<e;o++)n=n.parent;for(let o=i;o<e;o++)n=n.child(s[o]);return new k(s,{...this.tag,...t},this.keys,n)}}class M{constructor(t,e){this.children=new Map,this.entries=e,this.parent=t}child(t){const e=this.children.get(t);if(e)return e;const s=this.entries.flatMap(n=>n.subset(t)),i=new M(this,s);return this.children.set(t,i),i}}class ${constructor(t,e){this.internal=new v(e),this.tagLen=t}refExact(t){let e=this.internal;const s=this.tagLen;for(let i=0;i<s;i++)e=e.exact(t[i]);return e.values}}class v{constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const i of Object.values(s))for(const[n,o]of Object.entries(i))this.children.set(+n,new v(o))}exact(t){let e=this.children.get(t);return e||(e=new v({}),this.children.set(t,e),e)}}const y={sum:a=>a.reduce((t,e)=>t+e,0),prod:a=>a.reduce((t,e)=>t*e,1),min:a=>Math.min(...a),max:a=>Math.max(...a),sumfrac:([a,t])=>a/(a+t),unique:([a])=>a},_={match:([a,t])=>a===t?0:1,thres:([a,t])=>a>=t?0:1,lookup:([a],t)=>t[a]??0},b=a=>H(a,"val");let S=class{constructor(t,...e){this.keys=new q(t),this.nodes=new P(t.tagLen,z(e)),this.calculated=new $(t.tagLen,{})}gather(t){return this._gather(this.nodes.cache(this.keys).with(t)).pre}compute(t){return this._compute(t,this.nodes.cache(this.keys))}_gather(t){const e=this.calculated.refExact(t.id);return e.length||e.push({pre:t.subset().flatMap(s=>s.op==="reread"?this._gather(t.with(s.tag)).pre:[this.markGathered(t.tag,s,this._compute(s,t))])}),e[0]}_compute(t,e){const s=(n,o,c,r)=>Object.freeze({val:n,meta:this.computeMeta(t,n,o,c,r)}),{op:i}=t;switch(i){case"const":return s(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const n=t.x.map(o=>this._compute(o,e));return s(y[i](b(n),t.ex),n,[])}case"thres":case"match":case"lookup":{const n=t.br.map(h=>this._compute(h,e)),o=_[i](b(n),t.ex),c=[...Array(t.x.length)],r=this._compute(t.x[o],e);return c[o]=r,s(r.val,c,n)}case"subscript":{const n=this._compute(t.br[0],e);return s(t.ex[n.val],[],[n])}case"vtag":return s(e.tag[t.ex]??"",[],[]);case"tag":{const n=e.with(t.tag),o=this._compute(t.x[0],n);return s(o.val,[o],[],n.tag)}case"dtag":{const n=t.br.map(r=>this._compute(r,e)),o=e.with(Object.fromEntries(n.map((r,h)=>[t.ex[h],r.val]))),c=this._compute(t.x[0],o);return s(c.val,[c],n,o.tag)}case"read":{const n=e.with(t.tag),o=this._gather(n),{pre:c}=o,r=t.ex??"unique";if(o[r])return o[r];const h=y[r](b(c),void 0);return o[r]=s(h,c,[],n.tag),o[r]}case"custom":{const n=t.x.map(o=>this._compute(o,e));return s(this.computeCustom(b(n),t.ex),n,[])}default:C(i)}}markGathered(t,e,s){return s}computeCustom(t,e){throw new Error(`Unsupported custom node ${e} in Calculator`)}computeMeta(t,e,s,i,n){}};function ut(a,t,e){function s(c,r){const h=e(c.tag);return h?[A(h,r)]:c.subset().flatMap(u=>u.op!=="reread"?n(u,c):s(c.with(u.tag),r))}function i(c,r,h){return c.every(u=>u.op==="const")?g(y[r](c.map(u=>u.ex),h)):{op:r,x:c,br:[]}}function n(c,r){const{op:h}=c;switch(h){case"const":return c;case"read":{const u=s(r.with(c.tag),c.ex);return c.ex===void 0?u[0]??g(void 0):i(u,c.ex,c.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=c.x.map(d=>n(d,r));return i(u,h,c.ex)}case"thres":case"match":case"lookup":{const u=c.br.map(d=>n(d,r));if(u.every(d=>d.op==="const")){const d=_[c.op](u.map(l=>l.ex),c.ex);return n(c.x[d],r)}return{...c,x:c.x.map(d=>n(d,r)),br:u}}case"subscript":{const u=n(c.br[0],r);return u.op==="const"?g(c.ex[u.ex]):{...c,br:[u]}}case"vtag":return g(r.tag[c.ex]??"");case"tag":return n(c.x[0],r.with(c.tag));case"dtag":{const u=c.br.map(l=>n(l,r));if(u.some(l=>l.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const d=r.with(Object.fromEntries(u.map((l,f)=>[c.ex[f],l.ex])));return n(c.x[0],d)}case"custom":return{...c,x:c.x.map(u=>n(u,r))};default:C(h)}}const o=t.nodes.cache(t.keys);return a.map(c=>n(c,o))}function Y(a,t){const e=new Map;function s(i){const n=e.get(i);if(n)return n;const o=t(i,s);return e.set(i,o),o}return tt(a,s)}function Z(a,t){const e=new Set;function s(i){e.has(i)||(t(i,s),e.add(i))}a.forEach(s)}function tt(a,t){const e=a.map(t);return a.every((s,i)=>s===e[i])?a:e}const et={arithmetic:y,branching:_},x=Symbol();class st extends S{constructor(t,e){super(t.keys),this.nodes=t.nodes,this.tagStr=e,this.custom=t.computeCustom}checkCycle(t){rt(t,this)}_gather(t){return super._gather(t)}_compute(t,e){try{return super._compute(t,e)}catch(s){return{val:NaN,meta:{note:`err: ${s.message} in ${this.tagStr(e.tag)}`,formula:this.nodeString(t),deps:[],[x]:!0}}}}computeMeta(t,e,s,i,n){function o(r){return typeof r!="number"?`"${r}"`:Math.round(r)===r?`${r}`:r.toFixed(2)}const c={note:"",formula:`[${o(e)}] ${this.nodeString(t)}`,deps:[...s.map(r=>r==null?void 0:r.meta).filter(r=>!!r),...i.map(r=>r.meta)].flatMap(r=>r[x]?[r]:r.deps),[x]:t.op==="read"};return t.op==="read"?(n=Object.fromEntries(Object.entries(n).filter(([r,h])=>h)),c.note=`gather ${s.length} node(s) for ${this.tagStr(n)}`,c.formula=`[${o(e)}] read ${this.nodeString(t)}`,c.deps=s.map(r=>r.meta)):delete c.note,c}computeCustom(t,e){return this.custom(t,e)}nodeString(t){return Y([t],(e,s)=>{const{op:i,tag:n,br:o,x:c}=e;let{ex:r}=e;if(i==="const")return`${r}`;if(i==="read")return this.tagStr(n,r);i==="subscript"&&(r=void 0);const h=[];return r&&h.push(JSON.stringify(r)),n&&h.push(this.tagStr(n)),h.push(...o.map(s),...c.map(s)),`${i}(`+h.join(", ")+")"})[0]}}function rt(a,t){const e=[],s=t.keys,i=new $(s.tagLen,{});function n(o){const c=o.tag,r=i.refExact(s.get(c));if(r[0]>0)throw console.log(e.slice(r[0]-1)),new Error("Cyclical dependencies found");if(r[0]==0)return;r[0]=e.push(c);const h=o.subset(),u=h.filter(l=>l.op!=="reread"),d=h.filter(l=>l.op==="reread");Z(u,(l,f)=>{switch(l.op){case"read":{const m=o.with(l.tag);n(m);return}case"tag":{f(l.x[0]);return}case"dtag":console.warn("Ignored dtag node while checking for cycles")}l.x.forEach(f),l.br.forEach(f)});for(const{tag:l}of d){const f=o.with(l);n(f)}r[0]=0,e.pop()}n(t.nodes.cache(t.keys).with(a))}const nt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class ot extends S{computeMeta({op:t,ex:e},s,i,n,o){const c={...nt},r=i.filter(l=>!!l).map(l=>j(l,c));n.forEach(l=>j(l,c));function h(l,f){return!f.tag&&l?{tag:l,...f}:f}function u(l,f){return h(o,{op:l,ops:f,...c})}function d(l){const f=l.meta,m=f.conds===c.conds;return h(o,m?f:{...f,...c})}if(t==="read"&&e!==void 0){if(e==="min"||e==="max")return d(r.find(l=>l.val===s));t=e,e=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let l=r;if(l.length>1){const f=at[t]([],e);l=l.filter(m=>m.val!==f)}return l.length===1?d(l[0]):l.length===0?u("const",[]):u(t,l)}case"const":case"vtag":case"subscript":return u("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return d(r[0]);case"read":return Object.freeze(d(r[0]));case"custom":return u(e,r);default:B(t)}}markGathered(t,e,s){let i=!1;const n=s.val,o={...Object.freeze(s.meta)};if(t.qt==="cond"){const{src:c,dst:r,sheet:h,q:u}=t;o.conds={[r??"all"]:{[c??"all"]:{[h]:{[u]:n}}}},i=!0}return Object.freeze(o),i?{val:n,meta:o}:s}listFormulas(t){return this.gather(t.tag).filter(e=>e.val).map(({val:e,meta:s})=>p.withTag(s.tag)[e])}listCondFormulas(t){return this.listFormulas(t).map(e=>this.compute(e).meta.conds).reduce(L,{})}toDebug(){return new st(this,V)}}function j(a,t){const{conds:e,...s}=a.meta;return t.conds=L(t.conds,e),Object.isFrozen(a.meta)?a:{val:a.val,meta:s}}function L(a,t){return D(a,t,(e,s)=>typeof s=="number"?s:void 0)}function D(a,t,e){const s=e(a,t);if(s!==void 0)return s;if(Object.keys(a).length<Object.keys(t).length&&([a,t]=[t,a]),!Object.keys(t).length)return a;let i=!1;const n={...a};for(const[o,c]of Object.entries(t)){const r=n[o],h=o in n?D(r,c,e):c;r!==h&&(n[o]=h,i=!0)}return i?n:a}function lt(a,...t){return t.map(({tag:e,value:s})=>({tag:{...e,src:a},value:s}))}function ht(a){const{lvl:t,basic:e,skill:s,ult:i,talent:n,ascension:o,eidolon:c}=E.char,{char:r,iso:h,[a.key]:u}=p.withAll("sheet",[]);return[r.reread(u),h.reread(u),t.add(a.level),e.add(a.basic),s.add(a.skill),i.add(a.ult),n.add(a.talent),o.add(a.ascension),c.add(a.eidolon),...I.map(d=>w.char[`statBoost${d}`].add(a.statBoosts[d]?1:0)),...K.map(d=>w.char[`bonusAbility${d}`].add(a.bonusAbilities[d]?1:0)),w.premod.crit_.add(.05),w.premod.crit_dmg_.add(.5)]}function dt(a){if(!a)return[];const{lvl:t,ascension:e,superimpose:s}=E.lightCone;return[p.sheet("lightCone").reread(p.sheet(a.key)),t.add(a.level),e.add(a.ascension),s.add(a.superimpose)]}function ft(a){const{common:{count:t},premod:e}=F(N,{sheet:"relic",et:"self"}),s={},i={};for(const{set:n,stats:o}of a){const c=s[n];c===void 0?s[n]=1:s[n]=c+1;for(const{key:r,value:h}of o){const u=i[r];u===void 0?i[r]=h:i[r]=u+h}}return[p.sheet("agg").reread(p.sheet("relic")),p.withTag({sheet:"relic",qt:"premod"}).reread(p.sheet("dyn")),...Object.entries(i).map(([n,o])=>G(e,n).sheet("dyn").add(o)),...Object.entries(s).map(([n,o])=>t.sheet(n).add(o))]}function pt(a){const t=p.with("et","team"),{self:e,enemy:s,teamBuff:i,notSelfBuff:n}=p.sheet("agg").withAll("et",[]);return[a.map(o=>p.withTag({et:"target",dst:o}).reread(p.withTag({et:"self",dst:null,src:o}))),a.flatMap(o=>{const c=e.with("src",o);return a.map(r=>c.reread(i.withTag({dst:o,src:r,name:null})))}),a.flatMap(o=>{const c=e.with("src",o);return a.filter(r=>r!==o).map(r=>c.reread(n.withTag({dst:o,src:r,name:null})))}),a.map(o=>s.reread(p.withTag({et:"enemyDeBuff",dst:null,src:o,name:null}))),a.flatMap((o,c)=>{const{stackIn:r,stackTmp:h}=p.withAll("qt",[]),u=p.withTag({src:o,et:"self"});return[u.with("qt","stackTmp").add(R(r,0,c+1)),u.with("qt","stackOut").add(U(h.max.with("et","team"),c+1,r))]}),a.map(o=>t.add(p.withTag({src:o,et:"self"}).sum))].flat()}function mt(a,t){return Object.entries(t).flatMap(([e,s])=>Object.entries(s).flatMap(([i,n])=>{const o=J(i,e,a);return Object.entries(n).map(([c,r])=>o(c,r))}))}function gt(a){const t=W(O,a);return new ot(O,X,t)}export{mt as a,ht as c,ut as d,dt as l,ft as r,gt as s,pt as t,lt as w};
