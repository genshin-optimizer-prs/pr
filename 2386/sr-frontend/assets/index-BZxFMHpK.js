import{bl as q,bm as z,bn as g,bo as A,bp as B,bq as p,br as V,bs as E,bt as I,aK as w,bu as K,ah as F,ai as N,bv as G,bw as R,bx as U,by as J,bz as W,bA as O,bB as X}from"./index-Cw3mL1YQ.js";function C(o){throw new Error(`Should not reach this with value ${o}`)}const H=(o,t)=>o.map(e=>e[t]);class P{constructor(t,e){this.internal=new Q(e),this.tagLen=t}allValues(){const t=[],e=this.tagLen;function s(i,n){n===e?t.push(...i.values):i.children.forEach(a=>a.forEach(c=>s(c,n+1)))}return s(this.internal,0),t}subset(t){const e=[],s=this.tagLen;function i(n,a){a===s?e.push(...n.values):n.subset(t[a]).forEach(c=>i(c,a+1))}return i(this.internal,0),e}cache(t){const e=t.tagLen;let s=new M(void 0,[this.internal]);for(let i=0;i<e;i++)s=s.child(0);return new k(new Int32Array(e).fill(0),{},t,s)}}let Q=class T{constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const[i,n]of Object.entries(s)){const a=new Map;this.children.set(+i,a);for(const[c,r]of Object.entries(n))a.set(+c,new T(r))}}subset(t){return[...this.children].map(([e,s])=>s.get(t&e)).filter(e=>e)}};class k{constructor(t,e,s,i){this.id=t,this.tag=e,this.keys=s,this.tagLen=s.tagLen,this.internal=i}subset(){return this.internal.entries.flatMap(t=>t.values)}tags(){throw new Error("Tags are not tracked in production")}with(t){const{tagLen:e}=this.keys,{id:s,firstReplacedByte:i}=this.keys.combine(this.id,t);let n=this.internal;for(let a=i;a<e;a++)n=n.parent;for(let a=i;a<e;a++)n=n.child(s[a]);return new k(s,{...this.tag,...t},this.keys,n)}}class M{constructor(t,e){this.children=new Map,this.entries=e,this.parent=t}child(t){const e=this.children.get(t);if(e)return e;const s=this.entries.flatMap(n=>n.subset(t)),i=new M(this,s);return this.children.set(t,i),i}}class ${constructor(t,e){this.internal=new v(e),this.tagLen=t}refExact(t){let e=this.internal;const s=this.tagLen;for(let i=0;i<s;i++)e=e.exact(t[i]);return e.values}}class v{constructor(t){const{"":e,...s}=t;this.children=new Map,this.values=e??[];for(const i of Object.values(s))for(const[n,a]of Object.entries(i))this.children.set(+n,new v(a))}exact(t){let e=this.children.get(t);return e||(e=new v({}),this.children.set(t,e),e)}}const y={sum:o=>o.reduce((t,e)=>t+e,0),prod:o=>o.reduce((t,e)=>t*e,1),min:o=>Math.min(...o),max:o=>Math.max(...o),sumfrac:([o,t])=>o/(o+t),unique:([o])=>o},_={match:([o,t])=>o===t?0:1,thres:([o,t])=>o>=t?0:1,lookup:([o],t)=>t[o]??0},b=o=>H(o,"val");let S=class{constructor(t,...e){this.keys=new q(t),this.nodes=new P(t.tagLen,z(e)),this.calculated=new $(t.tagLen,{})}gather(t){return this._gather(this.nodes.cache(this.keys).with(t)).pre}compute(t){return this._compute(t,this.nodes.cache(this.keys))}_gather(t){const e=this.calculated.refExact(t.id);return e.length||e.push({pre:t.subset().flatMap(s=>s.op==="reread"?this._gather(t.with(s.tag)).pre:[this.markGathered(t.tag,s,this._compute(s,t))])}),e[0]}_compute(t,e){const s=(n,a,c,r)=>Object.freeze({val:n,meta:this.computeMeta(t,n,a,c,r)}),{op:i}=t;switch(i){case"const":return s(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const n=t.x.map(a=>this._compute(a,e));return s(y[i](b(n),t.ex),n,[])}case"thres":case"match":case"lookup":{const n=t.br.map(h=>this._compute(h,e)),a=_[i](b(n),t.ex),c=[...Array(t.x.length)],r=this._compute(t.x[a],e);return c[a]=r,s(r.val,c,n)}case"subscript":{const n=this._compute(t.br[0],e);return s(t.ex[n.val],[],[n])}case"vtag":return s(e.tag[t.ex]??"",[],[]);case"tag":{const n=e.with(t.tag),a=this._compute(t.x[0],n);return s(a.val,[a],[],n.tag)}case"dtag":{const n=t.br.map(r=>this._compute(r,e)),a=e.with(Object.fromEntries(n.map((r,h)=>[t.ex[h],r.val]))),c=this._compute(t.x[0],a);return s(c.val,[c],n,a.tag)}case"read":{const n=e.with(t.tag),a=this._gather(n),{pre:c}=a,r=t.ex??"unique";if(a[r])return a[r];const h=y[r](b(c),void 0);return a[r]=s(h,c,[],n.tag),a[r]}case"custom":{const n=t.x.map(a=>this._compute(a,e));return s(this.computeCustom(b(n),t.ex),n,[])}default:C(i)}}markGathered(t,e,s){return s}computeCustom(t,e){throw new Error(`Unsupported custom node ${e} in Calculator`)}computeMeta(t,e,s,i,n){}};function ut(o,t,e){function s(c,r){const h=e(c.tag);return h?[A(h,r)]:c.subset().flatMap(u=>u.op!=="reread"?n(u,c):s(c.with(u.tag),r))}function i(c,r,h){return c.every(u=>u.op==="const")?g(y[r](c.map(u=>u.ex),h)):{op:r,x:c,br:[]}}function n(c,r){const{op:h}=c;switch(h){case"const":return c;case"read":{const u=s(r.with(c.tag),c.ex);return c.ex===void 0?u[0]??g(void 0):i(u,c.ex,c.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=c.x.map(d=>n(d,r));return i(u,h,c.ex)}case"thres":case"match":case"lookup":{const u=c.br.map(d=>n(d,r));if(u.every(d=>d.op==="const")){const d=_[c.op](u.map(l=>l.ex),c.ex);return n(c.x[d],r)}return{...c,x:c.x.map(d=>n(d,r)),br:u}}case"subscript":{const u=n(c.br[0],r);return u.op==="const"?g(c.ex[u.ex]):{...c,br:[u]}}case"vtag":return g(r.tag[c.ex]??"");case"tag":return n(c.x[0],r.with(c.tag));case"dtag":{const u=c.br.map(l=>n(l,r));if(u.some(l=>l.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const d=r.with(Object.fromEntries(u.map((l,f)=>[c.ex[f],l.ex])));return n(c.x[0],d)}case"custom":return{...c,x:c.x.map(u=>n(u,r))};default:C(h)}}const a=t.nodes.cache(t.keys);return o.map(c=>n(c,a))}function Y(o,t){const e=new Map;function s(i){const n=e.get(i);if(n)return n;const a=t(i,s);return e.set(i,a),a}return tt(o,s)}function Z(o,t){const e=new Set;function s(i){e.has(i)||(t(i,s),e.add(i))}o.forEach(s)}function tt(o,t){const e=o.map(t);return o.every((s,i)=>s===e[i])?o:e}const et={arithmetic:y,branching:_},x=Symbol();class st extends S{constructor(t,e){super(t.keys),this.nodes=t.nodes,this.tagStr=e,this.custom=t.computeCustom}checkCycle(t){rt(t,this)}_gather(t){return super._gather(t)}_compute(t,e){try{return super._compute(t,e)}catch(s){return{val:NaN,meta:{note:`err: ${s.message} in ${this.tagStr(e.tag)}`,formula:this.nodeString(t),deps:[],[x]:!0}}}}computeMeta(t,e,s,i,n){function a(r){return typeof r!="number"?`"${r}"`:Math.round(r)===r?`${r}`:r.toFixed(2)}const c={note:"",formula:`[${a(e)}] ${this.nodeString(t)}`,deps:[...s.map(r=>r==null?void 0:r.meta).filter(r=>!!r),...i.map(r=>r.meta)].flatMap(r=>r[x]?[r]:r.deps),[x]:t.op==="read"};return t.op==="read"?(n=Object.fromEntries(Object.entries(n).filter(([r,h])=>h)),c.note=`gather ${s.length} node(s) for ${this.tagStr(n)}`,c.formula=`[${a(e)}] read ${this.nodeString(t)}`,c.deps=s.map(r=>r.meta)):delete c.note,c}computeCustom(t,e){return this.custom(t,e)}nodeString(t){return Y([t],(e,s)=>{const{op:i,tag:n,br:a,x:c}=e;let{ex:r}=e;if(i==="const")return`${r}`;if(i==="read")return this.tagStr(n,r);i==="subscript"&&(r=void 0);const h=[];return r&&h.push(JSON.stringify(r)),n&&h.push(this.tagStr(n)),h.push(...a.map(s),...c.map(s)),`${i}(`+h.join(", ")+")"})[0]}}function rt(o,t){const e=[],s=t.keys,i=new $(s.tagLen,{});function n(a){const c=a.tag,r=i.refExact(s.get(c));if(r[0]>0)throw console.log(e.slice(r[0]-1)),new Error("Cyclical dependencies found");if(r[0]==0)return;r[0]=e.push(c);const h=a.subset(),u=h.filter(l=>l.op!=="reread"),d=h.filter(l=>l.op==="reread");Z(u,(l,f)=>{switch(l.op){case"read":{const m=a.with(l.tag);n(m);return}case"tag":{f(l.x[0]);return}case"dtag":console.warn("Ignored dtag node while checking for cycles")}l.x.forEach(f),l.br.forEach(f)});for(const{tag:l}of d){const f=a.with(l);n(f)}r[0]=0,e.pop()}n(t.nodes.cache(t.keys).with(o))}const nt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class ot extends S{computeMeta({op:t,ex:e},s,i,n,a){const c={...nt},r=i.filter(l=>!!l).map(l=>j(l,c));n.forEach(l=>j(l,c));function h(l,f){return!f.tag&&l?{tag:l,...f}:f}function u(l,f){return h(a,{op:l,ops:f,...c})}function d(l){const f=l.meta,m=f.conds===c.conds;return h(a,m?f:{...f,...c})}if(t==="read"&&e!==void 0){if(e==="min"||e==="max")return d(r.find(l=>l.val===s));t=e,e=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let l=r;if(l.length>1){const f=at[t]([],e);l=l.filter(m=>m.val!==f)}return l.length===1?d(l[0]):l.length===0?u("const",[]):u(t,l)}case"const":case"vtag":case"subscript":return u("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return d(r[0]);case"read":return Object.freeze(d(r[0]));case"custom":return u(e,r);default:B(t)}}markGathered(t,e,s){let i=!1;const n=s.val,a={...Object.freeze(s.meta)};if(t.qt==="cond"){const{src:c,dst:r,sheet:h,q:u}=t;a.conds={[r??null]:{[c??null]:{[h]:{[u]:n}}}},i=!0}return Object.freeze(a),i?{val:n,meta:a}:s}listFormulas(t){return this.gather(t.tag).filter(e=>e.val).map(({val:e,meta:s})=>p.withTag(s.tag)[e])}listCondFormulas(t){return this.listFormulas(t).map(e=>this.compute(e).meta.conds).reduce(L,{})}toDebug(){return new st(this,V)}}function j(o,t){const{conds:e,...s}=o.meta;return t.conds=L(t.conds,e),Object.isFrozen(o.meta)?o:{val:o.val,meta:s}}function L(o,t){return D(o,t,(e,s)=>typeof s=="number"?s:void 0)}function D(o,t,e){const s=e(o,t);if(s!==void 0)return s;if(Object.keys(o).length<Object.keys(t).length&&([o,t]=[t,o]),!Object.keys(t).length)return o;let i=!1;const n={...o};for(const[a,c]of Object.entries(t)){const r=n[a],h=a in n?D(r,c,e):c;r!==h&&(n[a]=h,i=!0)}return i?n:o}function lt(o,...t){return t.map(({tag:e,value:s})=>({tag:{...e,src:o},value:s}))}function ht(o){const{lvl:t,basic:e,skill:s,ult:i,talent:n,ascension:a,eidolon:c}=E.char,{char:r,iso:h,[o.key]:u}=p.withAll("sheet",[]);return[r.reread(u),h.reread(u),t.add(o.level),e.add(o.basic),s.add(o.skill),i.add(o.ult),n.add(o.talent),a.add(o.ascension),c.add(o.eidolon),...I.map(d=>w.char[`statBoost${d}`].add(o.statBoosts[d]?1:0)),...K.map(d=>w.char[`bonusAbility${d}`].add(o.bonusAbilities[d]?1:0)),w.premod.crit_.add(.05),w.premod.crit_dmg_.add(.5)]}function dt(o){if(!o)return[];const{lvl:t,ascension:e,superimpose:s}=E.lightCone;return[p.sheet("lightCone").reread(p.sheet(o.key)),t.add(o.level),e.add(o.ascension),s.add(o.superimpose)]}function ft(o){const{common:{count:t},premod:e}=F(N,{sheet:"relic",et:"self"}),s={},i={};for(const{set:n,stats:a}of o){const c=s[n];c===void 0?s[n]=1:s[n]=c+1;for(const{key:r,value:h}of a){const u=i[r];u===void 0?i[r]=h:i[r]=u+h}}return[p.sheet("agg").reread(p.sheet("relic")),p.withTag({sheet:"relic",qt:"premod"}).reread(p.sheet("dyn")),...Object.entries(i).map(([n,a])=>G(e,n).sheet("dyn").add(a)),...Object.entries(s).map(([n,a])=>t.sheet(n).add(a))]}function pt(o){const t=p.with("et","team"),{self:e,enemy:s,teamBuff:i,notSelfBuff:n}=p.sheet("agg").withAll("et",[]);return[o.map(a=>p.withTag({et:"target",dst:a}).reread(p.withTag({et:"self",dst:null,src:a}))),o.flatMap(a=>{const c=e.with("src",a);return o.map(r=>c.reread(i.withTag({dst:a,src:r,name:null})))}),o.flatMap(a=>{const c=e.with("src",a);return o.filter(r=>r!==a).map(r=>c.reread(n.withTag({dst:a,src:r,name:null})))}),o.map(a=>s.reread(p.withTag({et:"enemyDeBuff",dst:"all",src:a,name:null}))),o.flatMap((a,c)=>{const{stackIn:r,stackTmp:h}=p.withAll("qt",[]),u=p.withTag({src:a,et:"self"});return[u.with("qt","stackTmp").add(R(r,0,c+1)),u.with("qt","stackOut").add(U(h.max.with("et","team"),c+1,r))]}),o.map(a=>p.withTag({src:a,qt:"cond"}).reread(p.with("src","all"))),o.map(a=>t.add(p.withTag({src:a,et:"self"}).sum))].flat()}function mt(o,t){return Object.entries(t).flatMap(([e,s])=>Object.entries(s).flatMap(([i,n])=>{const a=J(i,e,o);return Object.entries(n).map(([c,r])=>a(c,r))}))}function gt(o){const t=W(O,o);return new ot(O,X,t)}export{mt as a,ht as c,ut as d,dt as l,ft as r,gt as s,pt as t,lt as w};
