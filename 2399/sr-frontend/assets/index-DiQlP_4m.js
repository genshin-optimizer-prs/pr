import{bq as p,br as s,bs as m,aM as h,bt as g,ah as w,ai as b,bu as y,bv as T,bw as k,bx as v,by as B,bz as M,bA as A,bB as q}from"./index-CQt_B8lx.js";function E(t,...n){return n.map(({tag:o,value:r})=>({tag:{...o,src:t},value:r}))}function O(t){const{lvl:n,basic:o,skill:r,ult:c,talent:l,ascension:e,eidolon:i}=p.char,{char:a,iso:d,[t.key]:u}=s.withAll("sheet",[]);return[a.reread(u),d.reread(u),n.add(t.level),o.add(t.basic),r.add(t.skill),c.add(t.ult),l.add(t.talent),e.add(t.ascension),i.add(t.eidolon),...m.map(f=>h.char[`statBoost${f}`].add(t.statBoosts[f]?1:0)),...g.map(f=>h.char[`bonusAbility${f}`].add(t.bonusAbilities[f]?1:0)),h.premod.crit_.add(.05),h.premod.crit_dmg_.add(.5)]}function j(t){if(!t)return[];const{lvl:n,ascension:o,superimpose:r}=p.lightCone;return[s.sheet("lightCone").reread(s.sheet(t.key)),n.add(t.level),o.add(t.ascension),r.add(t.superimpose)]}function C(t){const{common:{count:n},premod:o}=w(b,{sheet:"relic",et:"self"}),r={},c={};for(const{set:l,stats:e}of t){const i=r[l];i===void 0?r[l]=1:r[l]=i+1;for(const{key:a,value:d}of e){const u=c[a];u===void 0?c[a]=d:c[a]=u+d}}return[s.sheet("agg").reread(s.sheet("relic")),s.withTag({sheet:"relic",qt:"premod"}).reread(s.sheet("dyn")),...Object.entries(c).map(([l,e])=>y(o,l).sheet("dyn").add(e)),...Object.entries(r).map(([l,e])=>n.sheet(l).add(e))]}function K(t){const n=s.with("et","team"),{self:o,enemy:r,teamBuff:c,notSelfBuff:l}=s.sheet("agg").withAll("et",[]);return[t.map(e=>s.withTag({et:"target",dst:e}).reread(s.withTag({et:"self",dst:null,src:e}))),t.flatMap(e=>{const i=o.with("src",e);return t.map(a=>i.reread(c.withTag({dst:e,src:a,name:null})))}),t.flatMap(e=>{const i=o.with("src",e);return t.filter(a=>a!==e).map(a=>i.reread(l.withTag({dst:e,src:a,name:null})))}),t.map(e=>r.reread(s.withTag({et:"enemyDeBuff",dst:null,src:e,name:null}))),t.flatMap((e,i)=>{const{stackIn:a,stackTmp:d}=s.withAll("qt",[]),u=s.withTag({src:e,et:"self"});return[u.with("qt","stackTmp").add(T(a,0,i+1)),u.with("qt","stackOut").add(k(d.max.with("et","team"),i+1,a))]}),t.map(e=>n.add(s.withTag({src:e,et:"self"}).sum))].flat()}function S(t,n){return n?Object.entries(n).flatMap(([o,r])=>Object.entries(r).flatMap(([c,l])=>{const e=v(c,o,t);return Object.entries(l).map(([i,a])=>e(i,a))})):[]}function _(t){const n=B(M,t);return new A(q,n)}export{S as a,O as c,j as l,C as r,_ as s,K as t,E as w};
