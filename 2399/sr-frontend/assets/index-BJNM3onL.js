import{bp as q,bq as z,br as B,bs as A,bt as p,bu as F,bv as V,bw as d,bx as I,by as T,bz as K,aM as g,bA as G,ah as N,ai as U,bB as L,bC as R,bD as H,bE as J,bF as W,bG as O,bH as X}from"./index-Cvb_mgkm.js";function C(n){throw new Error(`Should not reach this with value ${n}`)}const P=(n,t)=>n.map(e=>e[t]);class Q{constructor(t,e){this.root=new Y(t,e)}subset(t){const e=[];return this._subset(t,r=>e.push(...r[q])),e}debugTag(t){const e=[];return this._subset(t,r=>e.push(...r[z])),e}_subset(t,e){const r=t.length;function c(a,s){a<r?s.subset(t[a]).forEach(o=>c(a+1,o)):e(s.leaf)}c(0,this.root)}}let Y=class S{constructor(t,e){if(this.children=[],t>0)for(const[r,c]of Object.entries(e)){const a=new Map;for(const[s,o]of Object.entries(c))a.set(+s,new S(t-1,o));this.children.push({mask:+r,map:a})}else this.leaf=e}subset(t){return this.children.map(({mask:e,map:r})=>r.get(t&e)).filter(e=>!!e)}};class _{constructor(t){this.root=new x(void 0),this.keys=t}at(t){const e=this.keys.get(t),r=e.reduce((c,a)=>c.child(a),this.root);return r.leaf||(r.leaf=new k(t,e,this.keys,r)),r.leaf}}class x{constructor(t){this.children=new Map,this.parent=t}child(t){let e=this.children.get(t);return e||(e=new x(this),this.children.set(t,e),e)}}class k{constructor(t,e,r,c){this.tag=t,this.id=e,this.keys=r,this.internal=c}with(t){const{keys:e}=this,{id:r,firstReplacedByte:c}=e.combine(this.id,t);let a=this.internal;for(let s=c;s<e.tagLen;s++)a=a.parent;for(let s=c;s<e.tagLen;s++)a=a.child(r[s]);return a.leaf||(a.leaf=new k({...this.tag,...t},r,e,a)),a.leaf}}const w={sum:n=>n.reduce((t,e)=>t+e,0),prod:n=>n.reduce((t,e)=>t*e,1),min:n=>Math.min(...n),max:n=>Math.max(...n),sumfrac:([n,t])=>n/(n+t),unique:([n])=>n},M={match:([n,t])=>n===t?0:1,thres:([n,t])=>n>=t?0:1,lookup:([n],t)=>t[n]??0},b=n=>P(n,"val");let $=class{constructor(t,...e){const r=new B(t);this.nodes=new Q(r.tagLen,A(e)),this.cache=new _(r).at({}),this.calc=new _(r).at({}),this.calc.val=this}withTag(t){const e=this.calc.with(t);return e.val??(e.val=Object.assign(new this.constructor(this.cache.keys),this,{cache:this.cache.with(t),calc:e}))}gather(t){return this._gather(this.cache.with(t)).pre}compute(t){return this._compute(t,this.cache)}_gather(t){if(t.val)return t.val;const e=this.nodes.subset(t.id).flatMap(r=>r.op==="reread"?this._gather(t.with(r.tag)).pre:[this.markGathered(t.tag,r,this._compute(r,t))]);return t.val={pre:e}}_compute(t,e){const r=(a,s,o,i)=>Object.freeze({val:a,meta:this.computeMeta(t,a,s,o,i)}),{op:c}=t;switch(c){case"const":return r(t.ex,[],[]);case"sum":case"prod":case"min":case"max":case"sumfrac":{const a=t.x.map(s=>this._compute(s,e));return r(w[c](b(a),t.ex),a,[])}case"thres":case"match":case"lookup":{const a=t.br.map(u=>this._compute(u,e)),s=M[c](b(a),t.ex),o=[...Array(t.x.length)],i=o[s]=this._compute(t.x[s],e);return r(i.val,o,a)}case"subscript":{const a=this._compute(t.br[0],e);return r(t.ex[a.val],[],[a])}case"vtag":return r(e.tag[t.ex]??"",[],[]);case"tag":{const a=e.with(t.tag),s=this._compute(t.x[0],a);return r(s.val,[s],[],a.tag)}case"dtag":{const a=t.br.map(i=>this._compute(i,e)),s=e.with(Object.fromEntries(a.map((i,u)=>[t.ex[u],i.val]))),o=this._compute(t.x[0],s);return r(o.val,[o],a,s.tag)}case"read":{const a=e.with(t.tag),s=this._gather(a),{pre:o}=s,i=t.ex??"unique";if(s[i])return s[i];const u=w[i](b(o),void 0);return s[i]=r(u,o,[],a.tag)}case"custom":{const a=t.x.map(s=>this._compute(s,e));return r(this.computeCustom(b(a),t.ex),a,[])}default:C(c)}}markGathered(t,e,r){return r}computeCustom(t,e){throw new Error(`Unsupported custom node ${e} in Calculator`)}computeMeta(t,e,r,c,a){}};function ct(n,t,e){function r(s,o){if(s.val)return s.val;const i=e(s.tag);return s.val=i?[F(i,o)]:t.nodes.subset(s.id).flatMap(u=>u.op!=="reread"?a(u,s):r(s.with(u.tag),o)),s.val}function c(s,o,i){return s.every(u=>u.op==="const")?p(w[o](s.map(u=>u.ex),i)):{op:o,x:s,br:[]}}function a(s,o){const{op:i}=s;switch(i){case"const":return s;case"read":{const u=r(o.with(s.tag),s.ex);return s.ex===void 0?u[0]??p(void 0):c(u,s.ex,s.ex)}case"sum":case"prod":case"min":case"max":case"sumfrac":{const u=s.x.map(l=>a(l,o));return c(u,i,s.ex)}case"thres":case"match":case"lookup":{const u=s.br.map(l=>a(l,o));if(u.every(l=>l.op==="const")){const l=M[s.op](u.map(m=>m.ex),s.ex);return a(s.x[l],o)}return{...s,x:s.x.map(l=>a(l,o)),br:u}}case"subscript":{const u=a(s.br[0],o);return u.op==="const"?p(s.ex[u.ex]):{...s,br:[u]}}case"vtag":return p(o.tag[s.ex]??"");case"tag":return a(s.x[0],o.with(s.tag));case"dtag":{const u=s.br.map(m=>a(m,o));if(u.some(m=>m.op!=="const"))throw new Error("Dynamic tag must be resolvable during detachment");const l=o.with(Object.fromEntries(u.map((m,h)=>[s.ex[h],m.ex])));return a(s.x[0],l)}case"custom":return{...s,x:s.x.map(u=>a(u,o))};default:C(i)}}return n.map(s=>a(s,new _(t.cache.keys).at({})))}function Z(n,t){const e=new Map;function r(c){const a=e.get(c);if(a)return a;const s=t(c,r);return e.set(c,s),s}return tt(n,r)}function tt(n,t){const e=n.map(t);return n.every((r,c)=>r===e[c])?n:e}const et={arithmetic:w,branching:M},v=Symbol();class st extends ${constructor(t,e){super(t.cache.keys),this.gathering=new Set,this.nodes=t.nodes,this.tagStr=e,this.custom=t.computeCustom}withTag(t){throw new Error("Unimplemented")}_gather(t){if(this.gathering.has(t))throw new Error("Loop detected for {this.tagStr(cache.tag)}");this.gathering.add(t);const e=this.__gather(t);return this.gathering.delete(t),e}__gather(t){return super._gather(t)}_compute(t,e){try{return super._compute(t,e)}catch(r){return{val:NaN,meta:{note:`err: ${r.message} in ${this.tagStr(e.tag)}`,formula:this.nodeString(t),deps:[],[v]:!0}}}}computeMeta(t,e,r,c,a){typeof e!="number"?e=`"${e}"`:Math.round(e)===e?e=`${e}`:e=e.toFixed(2);const s={note:"",formula:`[${e}] ${this.nodeString(t)}`,deps:[...r.map(o=>o==null?void 0:o.meta).filter(o=>!!o),...c.map(o=>o.meta)].flatMap(o=>o[v]?[o]:o.deps),[v]:t.op==="read"};return t.op==="read"?(a=Object.fromEntries(Object.entries(a).filter(([o,i])=>i)),s.note=`gather ${r.length} node(s) for ${this.tagStr(a)}`,s.deps=r.map(o=>o.meta)):delete s.note,s}computeCustom(t,e){return this.custom(t,e)}nodeString(t){return Z([t],(e,r)=>{const{op:c,tag:a,br:s,x:o}=e;let{ex:i}=e;if(c==="const")return`${i}`;if(c==="read")return this.tagStr(a,i);c==="subscript"&&(i=void 0);const u=[];return i&&u.push(JSON.stringify(i)),a&&u.push(this.tagStr(a)),u.push(...s.map(r),...o.map(r)),`${c}(`+u.join(", ")+")"})[0]}}const rt=Object.freeze({conds:Object.freeze({})}),{arithmetic:at}=et;class nt extends ${computeMeta({op:t,ex:e},r,c,a,s){const o={...rt},i=c.filter(h=>!!h).map(h=>j(h,o));a.forEach(h=>j(h,o));function u(h,f){return!f.tag&&h?{tag:h,...f}:f}function l(h,f){return u(s,{op:h,ops:f,...o})}function m(h){const f=h.meta,y=f.conds===o.conds;return u(s,y?f:{...f,...o})}if(t==="read"&&e!==void 0){if(e==="min"||e==="max")return m(i.find(h=>h.val===r));t=e,e=void 0}switch(t){case"sum":case"prod":case"min":case"max":case"sumfrac":{let h=i;if(h.length>1){const f=at[t]([],e);h=h.filter(y=>y.val!==f)}return h.length===1?m(h[0]):h.length===0?l("const",[]):l(t,h)}case"const":case"vtag":case"subscript":return l("const",[]);case"match":case"thres":case"lookup":case"tag":case"dtag":return m(i[0]);case"read":return Object.freeze(m(i[0]));case"custom":return l(e,i);default:V(t)}}markGathered(t,e,r){let c=!1;const a=r.val,s={...Object.freeze(r.meta)};if(t.qt==="cond"){const{src:o,dst:i,sheet:u,q:l}=t;s.conds={[i??"all"]:{[o??"all"]:{[u]:{[l]:a}}}},c=!0}return Object.freeze(s),c?{val:a,meta:s}:r}listFormulas(t){return this.gather(t.tag).filter(e=>e.val).map(({val:e,meta:r})=>d.withTag(r.tag)[e])}listCondFormulas(t){return this.listFormulas(t).map(e=>this.compute(e).meta.conds).reduce(E,{})}toDebug(){return new st(this,I)}}function j(n,t){const{conds:e,...r}=n.meta;return t.conds=E(t.conds,e),Object.isFrozen(n.meta)?n:{val:n.val,meta:r}}function E(n,t){return D(n,t,(e,r)=>typeof r=="number"?r:void 0)}function D(n,t,e){const r=e(n,t);if(r!==void 0)return r;if(Object.keys(n).length<Object.keys(t).length&&([n,t]=[t,n]),!Object.keys(t).length)return n;let c=!1;const a={...n};for(const[s,o]of Object.entries(t)){const i=a[s],u=s in a?D(i,o,e):o;i!==u&&(a[s]=u,c=!0)}return c?a:n}function ut(n,...t){return t.map(({tag:e,value:r})=>({tag:{...e,src:n},value:r}))}function lt(n){const{lvl:t,basic:e,skill:r,ult:c,talent:a,ascension:s,eidolon:o}=T.char,{char:i,iso:u,[n.key]:l}=d.withAll("sheet",[]);return[i.reread(l),u.reread(l),t.add(n.level),e.add(n.basic),r.add(n.skill),c.add(n.ult),a.add(n.talent),s.add(n.ascension),o.add(n.eidolon),...K.map(m=>g.char[`statBoost${m}`].add(n.statBoosts[m]?1:0)),...G.map(m=>g.char[`bonusAbility${m}`].add(n.bonusAbilities[m]?1:0)),g.premod.crit_.add(.05),g.premod.crit_dmg_.add(.5)]}function ht(n){if(!n)return[];const{lvl:t,ascension:e,superimpose:r}=T.lightCone;return[d.sheet("lightCone").reread(d.sheet(n.key)),t.add(n.level),e.add(n.ascension),r.add(n.superimpose)]}function mt(n){const{common:{count:t},premod:e}=N(U,{sheet:"relic",et:"self"}),r={},c={};for(const{set:a,stats:s}of n){const o=r[a];o===void 0?r[a]=1:r[a]=o+1;for(const{key:i,value:u}of s){const l=c[i];l===void 0?c[i]=u:c[i]=l+u}}return[d.sheet("agg").reread(d.sheet("relic")),d.withTag({sheet:"relic",qt:"premod"}).reread(d.sheet("dyn")),...Object.entries(c).map(([a,s])=>L(e,a).sheet("dyn").add(s)),...Object.entries(r).map(([a,s])=>t.sheet(a).add(s))]}function dt(n){const t=d.with("et","team"),{self:e,enemy:r,teamBuff:c,notSelfBuff:a}=d.sheet("agg").withAll("et",[]);return[n.map(s=>d.withTag({et:"target",dst:s}).reread(d.withTag({et:"self",dst:null,src:s}))),n.flatMap(s=>{const o=e.with("src",s);return n.map(i=>o.reread(c.withTag({dst:s,src:i,name:null})))}),n.flatMap(s=>{const o=e.with("src",s);return n.filter(i=>i!==s).map(i=>o.reread(a.withTag({dst:s,src:i,name:null})))}),n.map(s=>r.reread(d.withTag({et:"enemyDeBuff",dst:null,src:s,name:null}))),n.flatMap((s,o)=>{const{stackIn:i,stackTmp:u}=d.withAll("qt",[]),l=d.withTag({src:s,et:"self"});return[l.with("qt","stackTmp").add(R(i,0,o+1)),l.with("qt","stackOut").add(H(u.max.with("et","team"),o+1,i))]}),n.map(s=>t.add(d.withTag({src:s,et:"self"}).sum))].flat()}function ft(n,t){return t?Object.entries(t).flatMap(([e,r])=>Object.entries(r).flatMap(([c,a])=>{const s=J(c,e,n);return Object.entries(a).map(([o,i])=>s(o,i))})):[]}function pt(n){const t=W(O,n);return new nt(O,X,t)}export{ft as a,lt as c,ct as d,ht as l,mt as r,pt as s,dt as t,ut as w};
